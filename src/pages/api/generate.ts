import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
	if (req.method !== 'POST') {
		return res.status(405).json({ error: 'Method not allowed' })
	}

	try {
		const backend = process.env.NEXT_PUBLIC_API_URL || process.env.API_DESTINATION
		const body = typeof req.body === 'string' ? JSON.parse(req.body || '{}') : req.body || {}
		
		console.log('üéØ Generate API called with:', {
			description: body?.description?.substring(0, 100),
			name: body?.name,
			hasBackend: !!backend
		})

		if (backend) {
			// Proxy to Python backend generate endpoint
			let destination
			if (backend.startsWith('http://') || backend.startsWith('https://')) {
				destination = `${backend}/api/generate`
			} else if (backend.startsWith('/')) {
				destination = `${backend}/api/generate`
			} else {
				return res.status(500).json({ 
					error: 'Invalid backend configuration',
					backend_mode: 'config_error'
				})
			}

			console.log('üîó Proxying to Python backend:', destination)

			const resp = await fetch(destination, {
				method: 'POST',
				headers: { 
					'Content-Type': 'application/json',
					'Authorization': req.headers.authorization || ''
				},
				body: JSON.stringify(body)
			})

			console.log('üì° Backend response status:', resp.status)

			if (!resp.ok) {
				const errorData = await resp.text()
				console.error('‚ùå Backend error:', errorData)
				return res.status(resp.status).json({ 
					error: `Backend error ${resp.status}`,
					backend_response: errorData,
					backend_mode: 'proxy_error'
				})
			}

			const data = await resp.json()
			console.log('‚úÖ Backend response success:', {
				status: data.status,
				language: data.language_detected,
				files: data.files?.length || 0
			})

			return res.status(200).json(data)
		}

		// Fallback: Local mock implementation if no backend configured
		console.log('üîÑ Using local fallback implementation')
		
		const description = body?.description || 'Generated project'
		const name = body?.name || 'Generated Project'
		
		// Simple language detection fallback
		const lowerDesc = description.toLowerCase()
		let detectedLanguage = 'python'
		let projectType = 'CLI_TOOL'
		
		if (lowerDesc.includes('react') || lowerDesc.includes('web') || lowerDesc.includes('frontend')) {
			detectedLanguage = 'javascript'
			projectType = 'WEB_APP'
		} else if (lowerDesc.includes('api') || lowerDesc.includes('server') || lowerDesc.includes('backend')) {
			detectedLanguage = 'javascript'
			projectType = 'API'
		}

		// Generate mock files based on detected language
		const files: any[] = []
		if (detectedLanguage === 'python') {
			files.push({
				name: 'main.py',
				content: `#!/usr/bin/env python3
"""
${name}
${description}

Generated by Multi-Agent System (Local Fallback)
"""

def main():
    print("Hello from ${name}!")
    print("Description: ${description}")
    return 0

if __name__ == "__main__":
    main()`,
				type: 'code'
			})
			
			if (lowerDesc.includes('speech') || lowerDesc.includes('audio')) {
				files.push({
					name: 'requirements.txt',
					content: 'SpeechRecognition==3.10.0\npyaudio==0.2.11\ngoogletrans==4.0.0rc1',
					type: 'config'
				})
			}
		} else {
			files.push({
				name: 'App.jsx',
				content: `import React from 'react';

function App() {
  return (
    <div className="app">
      <h1>${name}</h1>
      <p>${description}</p>
      <p>Generated by Multi-Agent System (Local Fallback)</p>
    </div>
  );
}

export default App;`,
				type: 'code'
			})

			files.push({
				name: 'package.json',
				content: `{
  "name": "${name.toLowerCase().replace(/\\s+/g, '-')}",
  "version": "1.0.0",
  "description": "${description}",
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  }
}`,
				type: 'config'
			})
		}

		const jobId = `job_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`

		return res.status(200).json({
			status: 'success',
			backend_mode: 'local_fallback',
			language_detected: detectedLanguage,
			project_type: projectType,
			job_id: jobId,
			files: files,
			dependencies: detectedLanguage === 'python' ? ['SpeechRecognition', 'pyaudio'] : ['react', 'react-dom'],
			instructions: detectedLanguage === 'python' ? 'Run with: python main.py' : 'Run with: npm install && npm start',
			validation: {
				total_files: files.length,
				python_files: files.filter(f => f.name.endsWith('.py')).length,
				react_files: files.filter(f => f.name.endsWith('.jsx') || f.content.includes('React')).length,
				language_match: description.toLowerCase().includes(detectedLanguage)
			}
		})

	} catch (error: any) {
		console.error('‚ùå Generate endpoint error:', error)
		return res.status(500).json({ 
			error: error?.message || 'Failed to generate project',
			backend_mode: 'error',
			debug_info: {
				error_type: error?.constructor?.name,
				stack: error?.stack?.split('\n')[0]
			}
		})
	}
}